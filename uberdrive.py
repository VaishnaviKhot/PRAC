# -*- coding: utf-8 -*-
"""UberDrive.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VlvhjDeZJMXfqrZweDC_4QNDEHku1XfD
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

from google.colab import files
uploaded=files.upload()

import io
df=pd.read_csv(io.BytesIO(uploaded['Uberdata.csv']))
df

df=pd.read_csv('Uberdata.csv')
df

df.shape

df.head()

df.info()

df.isnull().sum()

#drop null values
df.dropna(axis=0,inplace=True)
df.isnull().sum()

#calculation of distance between the pickup and dropoff coordinates
#using Haversine formula for accuracy
def Haversine(lon_1,lon_2,lat_1,lat_2):
  lon_1,lon_2,lat_1,lat_2=map(np.radians,[lon_1,lon_2,lat_1,lat_2]) #Degrees to radians


  diff_lon=lon_2-lon_1
  diff_lat=lat_2-lat_1

  km=2*6371*np.arcsin(np.sqrt(np.sin(diff_lat/2.0)**2+ np.cos(lat_1)*np.cos(lat_2)*np.sin(diff_lon/2.0)**2))

  return km

#find distance travelled per ride
df['Distance']=Haversine(df['pickup_longitude'],df['dropoff_longitude'],df['pickup_latitude'],df['dropoff_latitude'])

#round it to 2 decimal pointsd
df['Distance']=df['Distance'].astype(float).round(2)
df.head()

plt.scatter(df['Distance'],df['fare_amount'])
plt.xlabel('Distance')
plt.ylabel('fare_amount')

#Outliers
#We can get rid of the distance with very large distance that are outliers
#as well as trips with 0 distance
df.drop(df[df['Distance']>60].index,inplace=True)
df.drop(df[df['Distance']==0].index,inplace=True)
df.drop(df[df['fare_amount']==0].index,inplace=True)
df.drop(df[df['fare_amount']<0].index,inplace=True)
df.shape



#removing rows with non plausible fare amount and distance travelled
df.drop(df[(df['fare_amount']>100) &(df['Distance']<1)].index,inplace=True)
df.drop(df[(df['fare_amount']<100) &(df['Distance']>100)].index,inplace=True)
df.shape

plt.scatter(df['Distance'],df['fare_amount'])
plt.xlabel('Distance')
plt.ylabel('fare_amount')

# Create New Dataframe of Specific Column
df2=pd.DataFrame().assign(fare=df['fare_amount'],Distance=df['Distance'])
df2.info()

df2.shape

#plot target fare distribution
plt.figure(figsize=[8,4])
sns.distplot(df2['fare'],color='g',hist_kws=dict(edgecolor='black',linewidth=2),bins=30)
plt.title('Target Variable Distribution')
plt.show()

#plots
plt.scatter(df2['Distance'],df2['fare'])
plt.xlabel('Distance')
plt.ylabel('fare_amount')

x=df2['fare']
y=df2['Distance']

#independent variable
x=df2['Distance'].values.reshape(-1,1)
#dependent variable
y=df2['fare'].values.reshape(-1,1)

# scale by standardscalser
from sklearn.preprocessing import StandardScaler
std=StandardScaler()
y_std=std.fit_transform(y)
x_std=std.fit_transform(x)
x_std

#split in train-test
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x_std,y_std,test_size=0.2,random_state=0)

#simple Linear Regression
from sklearn.linear_model import LinearRegression
l_reg=LinearRegression()
l_reg.fit(x_train,y_train)

#predict test values
y_pred=l_reg.predict(x_test)
y_pred

#find the error
from sklearn import metrics
print('Mean absolute Error:',metrics.mean_absolute_error(y_test,y_pred))
print('Mean Squared Error:',metrics.mean_squared_error(y_test,y_pred))
print('Root Mean Squared Error:',metrics.mean_absolute_error(y_test,y_pred))

#final plot
plt.subplot(2,2,1)
plt.scatter(x_train,y_train,color='red')
plt.plot(x_train,l_reg.predict(x_train),color='blue')
plt.title("Fare Vs distance(training Set)")
plt.ylabel("fare amount")
plt.xlabel("Distance")


plt.subplot(2,2,2)
plt.scatter(x_test,y_test,color='red')
plt.plot(x_train,l_reg.predict(x_train),color='blue')
plt.title("Fare Vs distance(test Set)")
plt.ylabel("fare amount")
plt.xlabel("Distance")